<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>


 function DistanceToLine(p, s, e) {
    // Calculate line length squared
    const lineLength2 = (e.x - s.x) * (e.x - s.x) + (e.z - s.z) * (e.z - s.z);
    
    if (lineLength2 === 0) {
        // If line is actually a point, return distance to that point
        return Math.sqrt((p.x - s.x) * (p.x - s.x) + (p.z - s.z) * (p.z - s.z));
    }
    
    // Calculate projection position (t) along line segment
    const t = Math.max(0, Math.min(1, (
        ((p.x - s.x) * (e.x - s.x) + (p.z - s.z) * (e.z - s.z)) / lineLength2
    )));
    
    // Calculate closest point on line
    const projectionX = s.x + t * (e.x - s.x);
    const projectionY = s.z + t * (e.z - s.z);
    
    // Return distance to closest point
    return Math.sqrt(
        (p.x - projectionX) * (p.x - projectionX) + 
        (p.z - projectionY) * (p.z - projectionY)
    );
}

var canvas = document.getElementById("renderCanvas");

var startRenderLoop = function (engine, canvas) {
    engine.runRenderLoop(function () {
        if (sceneToRender && sceneToRender.activeCamera) {
            sceneToRender.render();
        }
    });
}

var engine = null;
var scene = null;
var sceneToRender = null;
var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
var createScene = function () {
    const chunkSize = 128;
    const renderDist = 128;
    const maxDist = chunkSize*renderDist*2;
    const mountHeight = maxDist/16;
    console.log('mountHeight',mountHeight,'maxDist',maxDist);
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.5, 0.8, 0.89, 1);
    // scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
    // scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
    // scene.fogDensity = 0.0005;
    // scene.fogStart = 0;
    // scene.fogEnd = maxDist/2;
    // scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, mountHeight+2,10), scene);
    camera.maxZ = 50000;
    camera.speed = 10;
    camera.inverseRotationSpeed = 100;

    // This targets the camera to scene origin
    // camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    // var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    // // Default intensity is 1. Let's dim the light a small amount
    // light.intensity = 0.9;
    // light.specular = BABYLON.Color3.Black();

    var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, -1, 0), scene);
    light.intensity = 0.9;
    light.groundColor = new BABYLON.Color3(1,1,1);
    light.specular = BABYLON.Color3.Black();


    // Our built-in 'ground' shape.
    // var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    function getBaseLog(x, y) {
        return Math.log(y) / Math.log(x);
    }
    const BlockColor = [
        new BABYLON.Color4(0.9,0.8,0.1,1),
        new BABYLON.Color4(0.9,1,0,1),
        new BABYLON.Color4(1,0.8,0,1),
        new BABYLON.Color4(0.8,0.9,0,1),
        new BABYLON.Color4(0.1,9,0.1,1),
        new BABYLON.Color4(0,1,1,1),
    ];
    const BlockColor2 = [
        new BABYLON.Color4(0.8,0.7,0,1),
        new BABYLON.Color4(0.8,0.9,0,1),
        new BABYLON.Color4(0.9,0.7,0,1),
        new BABYLON.Color4(0.7,0.8,0,1),
        new BABYLON.Color4(0.1,0.8,0.1,1),
        new BABYLON.Color4(0,0.9,0.9,1),
    ];
    const LeafColor = [
        new BABYLON.Color4(0.2,0.3,0,1),
        new BABYLON.Color4(0.2,0.5,0,1),
        new BABYLON.Color4(0.2,0.3,0,1),
        new BABYLON.Color4(0.2,0.4,0,1),
        new BABYLON.Color4(0.0,0.4,0.1,1),
        new BABYLON.Color4(0,0.7,0.4,1),
    ];
    const snowColor = [
        new BABYLON.Color4(1,0.9,1,1),
        new BABYLON.Color4(0.9,0.9,1,1),
        new BABYLON.Color4(1,0.9,0.9,1),
        new BABYLON.Color4(0.9,1,1,1),
        new BABYLON.Color4(1,1,0.9,1),
        new BABYLON.Color4(0.9,0.9,1,1),
    ];
    const cloudColor = [
        new BABYLON.Color4(1,0.9,1,0.3),
        new BABYLON.Color4(0.9,0.9,1,0.3),
        new BABYLON.Color4(1,0.9,0.9,0.3),
        new BABYLON.Color4(0.9,1,1,0.3),
        new BABYLON.Color4(1,1,0.9,0.3),
        new BABYLON.Color4(0.9,0.9,1,0.3),
    ];
    let boxcount = 0;
    colorCodeMap = {
        'c1':BlockColor,
        'c2':BlockColor2,
        'leaf':LeafColor,
        'snow':snowColor,
        'cloud':cloudColor
    }
    const meshTypeMap = {}
    function GetInstance({colorCode,size,width,height,depth}){
        boxcount++;
        const meshCode = `${size}-${colorCode}-${width??1}-${height??1}-${depth??1}`;
        if (!(meshCode in meshTypeMap)) {
            const newMesh = BABYLON.MeshBuilder.CreateBox(`${meshCode}`, {size,width,height,depth,faceColors:colorCodeMap[colorCode]}, scene);
            newMesh.alwaysSelectAsActiveMesh = true;
            newMesh.position.y = -1000;
            // this is really slow :(
            // newMesh.isVisible = false;
            // newMesh.setParent(null);
            if (colorCode === 'cloud') newMesh.hasVertexAlpha = true
            meshTypeMap[meshCode] = newMesh;
        }
        const mesh = meshTypeMap[meshCode];
        const instance = mesh.createInstance(meshCode+boxcount);
        instance.alwaysSelectAsActiveMesh = true;
        return instance;
    }
    var boxration = 1;
    // const mountains = [
    //     {x:0,z:0},
    //     {x:maxDist/4,z:maxDist/4},
    //     {x:maxDist/4,z:maxDist/5},
    //     {x:maxDist/3.5,z:maxDist/5},
    //     {x:-maxDist/8,z:maxDist/8},
    // ];
    const mtnRange = [
        {x:-maxDist/4,z:0},
        {x:maxDist/4,z:0},
    ]
    const glacialPaths = [
        [
            {x:0,z:mountHeight/8},
            {x:0,z:maxDist/4},
        ],
        [
            {x:mountHeight/2,z:mountHeight/8},
            {x:mountHeight/2,z:maxDist/4},
        ],
    ]
    const snowStart = 0.9;
    function GetElevation(pos) {
        const distToRange = DistanceToLine(pos,mtnRange[0],mtnRange[1]);
        // const dist = Math.min(...mountains.map(mtn => Math.sqrt((pos.x-mtn.x)**2+(pos.z-mtn.z)**2)));
        const baseDepth = (2**(-distToRange/mountHeight)*mountHeight);
        const distToGlacier = Math.min(...glacialPaths.map(path => DistanceToLine(pos,path[0],path[1])));
        glacialDepression = Math.max(mountHeight/2-(distToGlacier/(mountHeight/4))**2*mountHeight,0);
        return Math.max(baseDepth-glacialDepression,0);
    }
    for (let i = -renderDist; i <= renderDist; i++) {
        for (let j = -renderDist; j <= renderDist; j++) {
            dist = Math.sqrt(i**2+j**2);
            // 122333344444444
            const tierMap = [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6];
            const tier = tierMap[Math.ceil(dist)] ??  Math.ceil(dist+1);
            const boxSize =Math.min(2**(tier),chunkSize);
            const boxesPerChunk = chunkSize/boxSize;
            const chunkPos = {x:i*chunkSize,z:j*chunkSize};
            chunkPos.y = GetElevation(chunkPos);
            for (let k = -boxesPerChunk/2; k < boxesPerChunk/2; k++) {
                for (let l = -boxesPerChunk/2; l < boxesPerChunk/2; l++) {
                    let colorCode = Math.random() > 0.5 ? 'c1' : 'c2';
                    const x = chunkPos.x+k*boxSize;
                    const z = chunkPos.z+l*boxSize;
                    const y = GetElevation({x,z})
                    
                    // if ((((y/mountHeight)-snowStart)*1/(1-snowStart)) > Math.random()) colorCode = 'snow';

                    const instance = GetInstance({colorCode,size:boxSize});
                    instance.position.x = x;
                    instance.position.z = z;
                    instance.position.y = y;
                }
            }
            // const hasClump = Math.random() < 0.5;
            const hasClump = i == j || i == -j;
            // const clumpSize = Math.random()*10;
            if (hasClump) {
                for (let i = 0; i < 20; i++) {
                    const leaf = GetInstance({colorCode:'leaf',size:1});
                    const x = chunkPos.x+Math.random()*20
                    const z = chunkPos.z+Math.random()*20;
                    const y = chunkPos.y + 150;
                    leaf.position.x = x;
                    leaf.position.z = z;
                    leaf.position.y = y;
                }
            }

            const hasCloud = Math.random() > 0.999;
            if (hasCloud) {
                const x = chunkPos.x-chunkSize/2+chunkSize*Math.random();
                const z = chunkPos.z-chunkSize/2+chunkSize*Math.random();
                const y = mountHeight*1.2 + Math.random()*100;
                const cloud = GetInstance({colorCode:'cloud',width:100,height:40,depth:300});
                cloud.position.x = x;
                cloud.position.z = z;
                cloud.position.y = y;
            }
        }
    }
    scene.freezeActiveMeshes();
    // setTimeout(() => {
    //     scene.freezeActiveMeshes();
        
    // }, 100000);
    console.log(boxcount);
    return scene;
};
    window.initFunction = async function() {
        
        
        
        var asyncEngineCreation = async function() {
            try {
            return createDefaultEngine();
            } catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
    initFunction().then(() => {sceneToRender = scene});

    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
        </script>
    </body>
</html>
