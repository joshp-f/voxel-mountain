<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    const chunkSize = 64;
    const renderDist = 32;
    const maxDist = chunkSize*renderDist*2;
    const mountHeight = maxDist/4;
    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, mountHeight+2,-maxDist/8), scene);

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.9;
    light.specular = BABYLON.Color3.Black();


    // Our built-in 'sphere' shape.
    // var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, scene);

    // Move the sphere upward 1/2 its height
    // sphere.position.y = 1;

    // Our built-in 'ground' shape.
    // var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    function getBaseLog(x, y) {
        return Math.log(y) / Math.log(x);
    }
    const BlockColor = [
        new BABYLON.Color4(0.9,0.8,0.1,1),
        new BABYLON.Color4(0.9,1,0,1),
        new BABYLON.Color4(1,0.8,0,1),
        new BABYLON.Color4(0.8,0.9,0,1),
        new BABYLON.Color4(0.1,9,0.1,1),
        new BABYLON.Color4(0,1,1,1),
    ];
    const BlockColor2 = [
        new BABYLON.Color4(0.8,0.7,0,1),
        new BABYLON.Color4(0.8,0.9,0,1),
        new BABYLON.Color4(0.9,0.7,0,1),
        new BABYLON.Color4(0.7,0.8,0,1),
        new BABYLON.Color4(0.1,0.8,0.1,1),
        new BABYLON.Color4(0,0.9,0.9,1),
    ];
    const LeafColor = [
        new BABYLON.Color4(0.4,0.5,0,1),
        new BABYLON.Color4(0.4,0.7,0,1),
        new BABYLON.Color4(0.5,0.5,0,1),
        new BABYLON.Color4(0.3,0.6,0,1),
        new BABYLON.Color4(0.0,0.6,0.1,1),
        new BABYLON.Color4(0,0.7,0.4,1),
    ];
    let boxcount = 0;
    for (let i = -renderDist; i <= renderDist; i++) {
        for (let j = -renderDist; j <= renderDist; j++) {
            dist = Math.sqrt(i**2+j**2);
            // 122333344444444
            const tierMap = [1,2,3,4,5];
            const tier = tierMap[Math.ceil(dist)] ??  Math.ceil(dist+1);
            const boxSize =Math.min(2**(tier),chunkSize);
            const boxesPerChunk = chunkSize/boxSize;
            for (let k = -boxesPerChunk/2; k < boxesPerChunk/2; k++) {
                for (let l = -boxesPerChunk/2; l < boxesPerChunk/2; l++) {
                    // var ground2 = BABYLON.MeshBuilder.CreateGround("ground", {width: 0.5*boxSize, height: 0.5*boxSize}, scene);
                    var boxration = 1;
                    const color = Math.random() > 0.5 ? BlockColor2 : BlockColor;
                    const x = i*chunkSize+k*boxSize;
                    const z = j*chunkSize+l*boxSize;
                    const blockDist = Math.sqrt(x**2+z**2);
                    const y = 2**(-blockDist/mountHeight)*mountHeight;
                    boxcount++;
                    var ground2 = BABYLON.MeshBuilder.CreateBox("box", {width: boxration*boxSize, height: boxration*boxSize,depth:boxration*boxSize,faceColors:color}, scene);
                    ground2.position.x = x;
                    ground2.position.z = z;
                    ground2.position.y = y;
                    ground2.alwaysSelectAsActiveMesh = true;
                    boxcount++;
                    var grass = BABYLON.MeshBuilder.CreateBox("box", {width: 1, height: 1,depth:1,faceColors:LeafColor}, scene);
                    grass.position.x = x;
                    grass.position.z = z;
                    grass.position.y = y+boxSize;
                    grass.alwaysSelectAsActiveMesh = true;
                }
            }
        }
    }
    scene.freezeActiveMeshes();
    console.log(boxcount);
    return scene;
};
    window.initFunction = async function() {
        
        
        
        var asyncEngineCreation = async function() {
            try {
            return createDefaultEngine();
            } catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
    initFunction().then(() => {sceneToRender = scene});

    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
        </script>
    </body>
</html>
